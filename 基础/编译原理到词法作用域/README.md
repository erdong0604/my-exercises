#### 编译原理
--
我们通常称`JavaScript`为 ‘解释性’ 语言，但其实是一门编译语言。

在传统编译语言的流程中，程序的代码在执行之前会经历三个步骤，统称为“编译”。

* 分词/词法分析

	这个过程会将有字符组成的字符串分解成有意义的代码块，这些代码块被称为词法单元。例如：代码`var a = 2`。这段diamante通常会被分解成下面的词法单元：var、a、=、2 、。

* 解析/词法分析

	这个过程是将词法单元流转换成一个有元素逐级嵌套所组成的代表程序语法结构的树。这个树被称之为“抽象语法树”(Abstract Syntax Tree，AST)。

* 代码生成

	将 AST 转换为可执行代码的过程被称为代码生成。这个过程与语言，目标平台等息息相关。

`JavaScript`引擎在这三个步骤之外还进行了一系列操作。例如：在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。

简单来说：任何`JavaScript`代码片段在执行前都要进行编译。因此`JavaScript`编译器在遇到`var a = 2`这段代码时，首先进行编译，做好执行它的准备，然后马上执行。

当我们运行`var a = 2`这段代码时，可以用一段话来概括其执行过程：为一个变量分配内存，将其命名为 a , 然后将值 2 保存进这个变量。

具体行为如下：

1. 当编译器遇到 `var a`，会去询问该作用域的集合中是否有一个该名称为 a 的变量。如果有，该声明就会被忽略，继续进行编译。否则它会要求作用域在当前作用域中声明一个变量 a 。
2. 接下来编译器会为引擎生成运行时所需要的代码，这些代码被用来处理`a = 2`这个赋值操作。引擎运行时首先会询问当前作用域：当前作用域内是否有一个叫做 a 的变量。如果有，引擎就会把 2 赋值给它。如果没有，引擎会继续查找该变量，直到找到全局作用域为止。如果早全局作用域内仍未找到 这个变量 a 。那么就会在作用域内声明一个变量 a 将 2 赋值给它。也就是我们常说的挂载到全局对象`Window`上。在严格模式下会抛出一个异常。

总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量(如果之前没有声明过)，然后在运行时引擎会在作用域内查找该变量，如果找到就对它赋值。

##### 编译器术语 LHS RHS

为了快速的理解两个术语，我进行了总结：

 我们用一段代码来解释
 ```
 var a = 1;
 console.log(a);
 ```
 第一句代码` var a = 1;` 执行的就是 LHS 操作，第二句代码就是`console.log(a)`就是 RHS 操作。当我们为一个变量赋值时进行的就是 LHS 操作，当我们去使用一个变量(函数)时，进行的就是 RHS 操作。
 
 ```
 function foo(a) {  // 这里 a 被赋值了 2 进行的是 LHS 操作
 	var b = a; // 这里b 被赋值了 a 的值 进行的是 LHS 操作 ，这里用到了 a 所以也进行了 RHS 操作
	return a + b; // 这里要使用 a 和 b 进行了两次 RHS 操作
 }
var c = foo( 2 ); // 这里c被赋值了一个函数foo 为LHS 操作   ，这里用到了 foo 所有也进行了 RHS 操作。
 ```
 
#### 作用域
--
作用域表面意思就是变量和函数可被作用的区域(范围)。也可以理解成一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套子作用域中根据标识符名称进行变量查找。

作用域有两工作模型，第一种为词法作用域，也叫静态作用域，也是大多数编程语言所采用的。另一种叫做动态作用域，仍有一些编程语言在使用，比如Bash脚本等。

`JavaScript`采用的就是词法(静态)作用域(lexical scoping)。
 
#### 词法作用域
--

词法作用域意味着作用域是由书写代码时函数声明的位置来决定的，编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何查找它们。

简单来说就是：词法作用域是在函数声明的时候就已经确定了，并且会一直保值不变(如果不做特殊处理)。无论这个函数在哪里被调用，被谁调用。
接下来看几个例子就明白了了：

```
var value = 1;

function foo() {
    console.log(value);
}

function bar() {
    var value = 2;
    foo();
}

bar();

```
首先执行 bar 函数，bar 作用域内有一个局部变量 value ，再执行 foo 函数，foo 函数内打印了一个 变量 value ，所以这个时候会去寻找 value 的值。我们说过函数的词法作用域是在书写(声明)的时候就确定了，所以会从书写的位置查找，并不会从调用的位置去查找，因此在 foo 函数作用域内没找到变量 value 就会去上层去寻找 找到全局的 value 变量，因此为 1。当在函数内部作用域内未找到时，并不会接着从调用它的位置去找，这点要记清楚。

在看两个例子，我们基本上就对词法作用域了解清楚了。

```
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();
```
```
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()();
```

这两段代码最后都会执行 f 函数。第一段代码中 f 函数是在 checkscope 函数内部执行的，当执行 f 函数时 会去 f 函数局部作用域中寻找 scope 变量，找不到就往上层查找，找到了 checkscope 函数局部变量 value 。第二段代码中 f 函数是在 checkscope 函数外部执行的，但是我们上面说过函数的词法作用域是声明时就确定了，因此它内部使用的变量 scope 在 f 函数声明时就确定了查找规则(先查找内部，找不到就往声明的位置向上层查找)，所以在 f 内部找不到 value 变量时就会去 checkscope 函数内查找。 所以执行的结果跟第一段代码相同。

总之函数词法作用域就一句话：变量的查找规则是从声明的位置开始向上层查找。






