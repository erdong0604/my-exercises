<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>防抖和节流</title>
</head>
<body>
    <p>
        没有节流<input type="text" id="input"/>
    </p>
    <p>
        节流后<input type="text" id="input1"/>
    </p>

    <br />


    <script>

        let ipt = document.getElementById('input');
        let ipt1 = document.getElementById('input1');

        // 用户输入内容实时反馈结果
        ipt.addEventListener('input',function(){
            let val = this.value;
            handleSendPhone(val);
        });

        let handler = throttle(handleSendPhone,1000);
        ipt1.addEventListener('input',function(){
            let val = this.value;
            handler(val);
        });

        // 请求接口
        function handleSendPhone(val){
            ajaxRequest({
                user:val
            }).then(res => {
                console.log(`请求结果为：${res}`)
            })
        }



        //模拟数据
        let items = ['abc','aaa','bbb','ccc','ddd'];
        //模拟ajax请求
        function ajaxRequest({user}){
            return new Promise((resolved,rejected) => {
                setTimeout(() => {
                    let res = items.includes(user)?'正确':'错误';
                    resolved(res);
                },200)
            });
        }



        /**
        * @fn : 要执行的函数
        * @delay : 执行函数的时间间隔
        */        

        function throttle(fn,delay){
            let timer;    // 定时器

            return function(...args){

                let context = this;

                // 如果timer存在，说明函数还未该执行 也就是距离上次函数执行未间隔指定的时间
                if(timer) return;

                // 如果函数执行之后还有函数还在触发，再延迟执行。
                timer = setTimeout(function(...args){
                    // 当函数执行时，让timer为null。
                    timer = null;
                    fn.apply(context,args);
                },delay);
            }
        }

    </script>




</body>
</html>