<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>防抖和节流</title>
</head>
<body>
    <p>
        没有防抖<input type="text" id="input"/>
    </p>
    <p>
        防抖后<input type="text" id="input1"/>
    </p>
    <p>
        立即执行版防抖<input type="text" id="input2"/>
    </p>

    <br />

    <!-- <input type="text" disabled  id="input2"/> -->

    <script>

        let ipt = document.getElementById('input');
        let ipt1 = document.getElementById('input1');
        let ipt2 = document.getElementById('input2');

        // 用户输入内容实时反馈结果
        ipt.addEventListener('input',function(){
            let val = this.value;
            handleSendPhone(val);
        });

        let handler = debounce(handleSendPhone,500,true);
        ipt1.addEventListener('input',function(){
            let val = this.value;
            handler(val);
        });

        let handler1 = debounce1(handleSendPhone,500,true);
        ipt2.addEventListener('input',function(){
            let val = this.value;
            handler1(val);
        });

        // 请求接口
        function handleSendPhone(val){
            ajaxRequest({
                user:val
            }).then(res => {
                console.log(res)
            })
        }



        //模拟数据
        let items = ['abc','aaa','bbb','ccc','ddd'];
        //模拟ajax请求
        function ajaxRequest({user}){
            return new Promise((resolved,rejected) => {
                setTimeout(() => {
                    let res = items.includes(user)?'正确':'错误';
                    resolved(res);
                },200)
            });
        }


        // 事件在触发n秒内再执行，如果在n秒内事件又被执行，则重新计算事件执行时间。如果在间隔n秒内一直触发该事件，则一直不执行。
        // 除非两次执行事件的间隔在n秒内。

        // 如果第二次执行时的时间 < 第一次执行时的时间+delay  就认为是在n秒内重复执行了，则重新计算事件执行时间

        // 利用setTimeout将传入的函数延迟执行，在延迟执行到达之前，如果函数又被执行，则清除定时器，让setTimeout重新计时。因此函数执行的条件为，在setTimeout计时结束前，传入的函数没有被再次执行，这时传入的函数就会执行。
    
        /**
        * @fn : 要执行的函数
        * @delay : 执行函数的时间间隔
        * @immediate : 是否第一次就执行函数
        */        

        function debounce1(fn,delay,immediate){

            let timer; // 定时器
 
            return function(...args){ // 形成闭包  外部执行的函数其实是这个return出去的函数。
                
                // args 为函数调用时传的参数。
                
                let context = this; // this 为函数执行时的this绑定。

                timer&&clearTimeout(timer); // 当函数再次执行时，清除定时器，让定时器重新开始计时

                // immediate为true 表示第一次触发就执行
                if(immediate){
                    // 执行一次之后赋值为false  
                    immediate = false;
                    fn.apply(context, args)
                }
                // 利用定时器，让指定函数延迟执行。
                timer = setTimeout(function(){

                    // immediate 赋值为true  下次输入时 还是会立即执行
                    immediate = true;
                    // 执行传入的指定函数，利用apply更改传入函数内部的this绑定，传入 args参数
                    fn.apply(context,args);
                },delay)
            }
        }

        function debounce(fn,delay){

let timer; // 定时器

return function(...args){ // 形成闭包  外部执行的函数其实是这个return出去的函数。
    
    // args 为函数调用时传的参数。
    
    let context = this; // this 为函数执行时的this绑定。

    timer&&clearTimeout(timer); // 当函数再次执行时，清除定时器，让定时器重新开始计时

    // 利用定时器，让指定函数延迟执行。
    timer = setTimeout(function(){
        
        // 执行传入的指定函数，利用apply更改this绑定和传参
        fn.apply(context,args);
    },delay)
}
}

    </script>




</body>
</html>